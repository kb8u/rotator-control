#!/usr/bin/perl
# Aim an M2 rotor using a GUI and map
# Written September 24, 2014 and copyright by Russell Dwarshuis, KB8U
# See the LICENSE files for terms of use.

# stuff to add or re-write:
# -shouldn't have $ob be global
# -don't use eval in sub movepix
# -bind alt-1 through alt-9 to speed selection
# -bind alt-x to exit
# -use entry fields to change heading and speed. bind cr to execute new entry
# -use degree symbol in the heading

# Include the Tk and serial port module
use Tk;
require Tk::Dialog;
use Device::SerialPort qw( :STAT 0.07 );
# File holding serial port configuration information used by Device::SerialPort
$COM_PORT_CONFIG_FILE = 'rotor.cfg';

# compass rose outer radius in pixels
$RADIUS = 417;
# .gif's of different ranges from station location
$EN71_745_GIF = './745.gif';
$EN71_1371_GIF = './2117.gif';
$EN71_2117_GIF = './2117.gif';
$EN71_5815_GIF = './5815.gif';
$EN71_11469_GIF = './11469.gif';

# send an opcode and get raw data back from rotor
# returns 1 on success, 0 otherwise
sub query_rotor {
  my ($command, $result_ref, $size) = @_;

  $ob -> write($command);

  my ($count_in, $string_in) = $ob->read($size);
  $$result_ref = $string_in;
  return 1 if $count_in == $size;

  $$result_ref = '';
  return 0
}


# update GUI
sub repeat_handler {
  my ($canv,$line_ref,$text_direction_ref,$text_speed_ref) = @_;

  my $result;
  my ($x,$y,$radians);
  query_rotor("\r",\$result,19);

  my ($a,$dummy,$limit_flag,$heading,$dummy,$speed,$dummy,$movement) = 
    unpack "A A2 A2 A5 A3 A A A2",$result;
  # check for invalid input
  unless ($a eq 'A') { return }
  unless (($limit_flag eq '=') || ($limit_flag eq '=-')) { return }
  $limit_flag = ($limit_flag eq '=') ? 0 : 1;

  # ignore junk lines (rotor sends it's own updates sometimes)
  unless ($heading =~ /\d{1,3}\.?\d?/) { return }
  unless (($speed>0) && ($speed <10)) { return }
  unless (($movement eq 'ST') || ($movement eq 'MV')) { return }
  $$text_direction_ref = int $heading;
  $heading -= 90; # adjust from rotors to Tk's idea of what angle represents
  $radians = 2*3.14159*($heading/360); # cos, sin needs radians, not degrees
  $x = int ($RADIUS * cos $radians);
  $y = int ($RADIUS * sin $radians);
  $canv->delete($$line_ref);
  $$line_ref = $canv->createLine(0,0,$x,$y,-fill => 'green', -width => 3);
  $$text_speed_ref = $speed;
  unless ($new_speed = $speed) { $ob->write("s$new_speed\r") }
}


# draw a line through the coordinates passed to the compas rose
sub heading_line {
  my ($line_ref,$canv,$cx,$cy,$color) = @_;
  my $angle = atan2($cy,$cx);
  my $rx = $RADIUS * cos $angle;
  my $ry = $RADIUS * sin $angle;
  $canv->delete($$line_ref);
  $$line_ref = $canv->createLine(0,0,$rx,$ry,-fill => $color, -width => 3);
}


# called when button 1 is double clicked; aims the rotator at cursor position
# and draws a red line to compass rose
sub aim_it {
  my ($canv, $x, $y, $line_ref) = @_;
  my $cx = $canv->canvasx($x);
  my $cy = $canv->canvasy($y); # y-axis is upside down from conventional system
  my $deg = atan2($cy,$cx)*360/(3.14159265359*2);
  # compass has 0 degrees at north, not east. 2nd quadrant needs +90+360,
  # others +90
  $deg = ($deg <-90) ? int ($deg+450) : int($deg + 90); 

  # place a red line at the selected heading
  heading_line($line_ref,$canv,$cx,$cy,"red");
  $deg = int $deg;
  $ob->write("$deg\r");
}


# bound to mouse movement; draws a black line through mouse position to
# compass rose
sub prelim_aim {
  my ($canv, $x, $y, $line_ref) = @_;
  my $cx = $canv->canvasx($x);
  my $cy = $canv->canvasy($y); # y-axis is upside down from conventional system
  my $deg = atan2($cy,$cx)*360/(3.14159265359*2);
  # compass has 0 degrees at north, not east. 2nd quadrant needs +90+360, others +90
  $deg = ($deg <-90) ? int ($deg+450) : int($deg + 90); 

  # place a black line at the selected heading
  heading_line($line_ref,$canv,$cx,$cy,"black");
}


sub exit_gracefully {
  undef $ob;
  exit;
}


# scroll the picture around using keys bound to this subroutine
sub movepix {
  my $calling_widget = shift;
  my $widget = shift;
  my $command = shift;
  my $whichway = shift;
  my $amount = shift;
  my $units = shift;
  # this is lame, $"$widget" has to be global
  eval ("\$$widget->$whichway"."view($command,$amount,$units)");
}


# change the map
sub set_range {
  my ($canvas,$pix,$pix_id_ref) = @_;
  my $sw_canvas = $canvas->Subwidget("canvas");

  # get rid of the old picture first
  $canvas->delete($$pix_id_ref);
  $$pix_id_ref = $canvas->createImage(0,0, -image => $pix, -anchor => 'center');
  $sw_canvas->lower($$pix_id_ref,'all');
  $canvas->configure(-scrollregion => [$canvas->bbox("all") ]);
  # initialize the view to more-or-less the middle of the drawing
  $canvas->xview('moveto',0.11);
  $canvas->yview('moveto',0.24);
}


# changes the rotor speed.
sub set_speed {
  my ($speed) = @_;
  $ob->write("s$speed\r");  # rotor has bug where occassionally the command is
  $ob->write("s$speed\r");  # ignored.  workaround is to send the command
  $ob->write("s$speed\r");  # three times...
}


########################## main #########################
my $port = '/dev/ttyS1';
$ob = new Device::SerialPort($port) || die "Can't open $port: $^E\n";

$ob->databits(8);
$ob->baudrate(9600);
$ob->parity("none");
$ob->stopbits(1);
$ob->handshake("none");

$ob->write_settings || undef $PortObj;

$ob->save($COM_PORT_CONFIG_FILE);

$ob->read_const_time(50);

$mw = new MainWindow;
$mw->title("M^2 Rotor control");

$canvas = $mw->Scrolled('Canvas', -height =>480, -width => 640,
                        -scrollbars => 'se');
$canvas->pack(-side => 'bottom', -anchor => 'center', -expand => 1,
              -fill => 'both');

# The three different ranges
$PIX_1 = $canvas->Photo(-file => $EN71_745_GIF);
$PIX_2 = $canvas->Photo(-file => $EN71_1371_GIF);
$PIX_3 = $canvas->Photo(-file => $EN71_2117_GIF);
$PIX_4 = $canvas->Photo(-file => $EN71_5815_GIF);
$PIX_5 = $canvas->Photo(-file => $EN71_11469_GIF);

# draw a range to start with
set_range($canvas,$PIX_1,\$pix_id);

# set the scroll region to the proper size
$canvas->configure(-scrollregion => [$canvas->bbox("all") ]);

# initialize the view to more-or-less the middle of the drawing
$canvas->xview('moveto',0.11);
$canvas->yview('moveto',0.24);

# bind keys to move the map around
$mw->bind("<Key-Up>", [ sub { $canvas->yview('scroll',-1,'units' )} ] );
$mw->bind("<Key-Down>", [ sub { $canvas->yview('scroll',1,'units' )} ] );
$mw->bind("<Key-Left>", [ sub { $canvas->xview('scroll',-1,'units' )} ] );
$mw->bind("<Key-Right>", [ sub { $canvas->xview('scroll',1,'units' )} ] );
$mw->bind("<Key-Home>", [ sub { $canvas->xview('moveto',0)} ] );
$mw->bind("<Key-End>", [ sub { $canvas->xview('moveto',1)} ] );
$mw->bind("<Key-Prior>", [ sub { $canvas->yview('moveto',0)} ] );
$mw->bind("<Key-Next>", [ sub { $canvas->yview('moveto',1)} ] );

# have to bind to stuff in the canvas, not the canvas itself
$sw_canvas = $canvas->Subwidget("canvas");
$sw_canvas->Tk::bind("<Double-Button-1>",
                     [ \&aim_it, Ev('x'), Ev('y'), \$desired_dir ]);
$sw_canvas->Tk::bind("<Motion>",
                    [ \&prelim_aim,  Ev('x'), Ev('y'), \$prelim_dir ]);
$sw_canvas->Tk::bind("<Leave>", [ sub { $canvas->delete($prelim_dir) }]);

# create frame for menus along the very top
$top_menu_frame = $mw->Frame
  (

   -borderwidth => 2,
   -height => 18,
   -width => 500,
  );
$top_menu_frame->pack(-side=>'top', -fill => 'x');
$top_menu_frame->packPropagate(0);
# place file and range menus in top_menu_frame
$file_menu = $top_menu_frame->Menubutton
  (
   -text => 'File',
   -tearoff => 0,
   -menuitems => [[ 'command' => "Exit", -command => \&exit_gracefully],]
  );
$file_menu->pack(-side =>'left');
$range[0]=['command'=>"745miles",-command=>[\&set_range,$canvas,$PIX_1,\$pix_id]];
$range[1]=['command'=>"1371miles",-command=>[\&set_range,$canvas,$PIX_2,\$pix_id]];
$range[2]=['command'=>"2117miles",-command=>[\&set_range,$canvas,$PIX_3,\$pix_id]];
$range[3]=['command'=>"5815miles",-command=>[\&set_range,$canvas,$PIX_4,\$pix_id]];
$range[4]=['command'=>"11469miles",-command=>[\&set_range,$canvas,$PIX_5,\$pix_id]];
$range_menu = $top_menu_frame->Menubutton
  (
   -text => 'Range',
   -tearoff => 0,
   -menuitems => \@range,
  );
$range_menu->pack(-side =>'left');

for($i=0;$i<9;$i++) {
  $speed[$i]=['command'=>$i+1,-command=>[\&set_speed,$i+1]];
}
$speed_menu = $top_menu_frame->Menubutton
  (
   -text => 'Speed',
   -tearoff => 0,
   -menuitems => \@speed,
  );
$speed_menu->pack(-side =>'left');

# a frame for the current beam heading, moving indicator and stop button
$info_frame = $mw->Frame
  (

   -borderwidth => 2,
   -height => 30,
   -width => 500,
  );
$info_frame->pack(-side=>'top', -fill => 'x');
$info_frame->packPropagate(0);
# a text entry field for current or desired direction
$direction_entry = $info_frame->Entry
  (
   -text => 'Beam heading',
   -textvariable => \$text_direction,
   -width => 3,
   -font => "Arial 12 bold",
   -foreground => "#00FF00",
   -background => 'black',
   -insertbackground => 'white',
  );
# numeric indicator/input of beam heading
$direction_entry->pack(-side =>'left');
$dir_descr_text = $info_frame->Label(-text=>'Heading')->pack(-side =>'left');

# a text entry field for current or desired speed
$speed_entry = $info_frame->Entry
  (
   -text => 'Speed',
   -textvariable => \$text_speed,
   -width => 1,
   -font => "Arial 12 bold",
   -foreground => "#00FF00",
   -background => 'black',
   -insertbackground => 'white',
  );
# numeric indicator/input of beam heading
$speed_entry->pack(-side =>'left');
$speed_descr_text = $info_frame->Label(-text=>'Speed')->pack(-side =>'left');

# button/indicator to stop beam movment/indicates movement
$stop_Button = $info_frame->Button
  (
   -text => 'STOP',
   -command => [ sub { $ob->write("s\r") } ],
  );
$stop_Button->pack(-side => 'left');
$dir_descr_text = $info_frame->Label(-text=>'Movement')->pack(-side =>'left');

$mw->repeat(100,[\&repeat_handler,$canvas,\$beam_pointer,\$text_direction,\$text_speed]);

MainLoop;
